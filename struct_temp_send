#include <RFM69.h>
#include <SPI.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <JeeLib.h>
#include <avr/sleep.h>

#define sDesc "Falco Manager Node"
#define sVersion "v0.5.1"
#define hVersion "v0.5.0"

//#define DEBUG_ON
#define DEBUG_MIN

#define ONE_WIRE_BUS 8
#define ONE_WIRE_POW 9
#define TEMPERATURE_PRECISION 12

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);
int numberOfDevices;
DeviceAddress tempDeviceAddress;
 
volatile bool adcDone;
ISR(ADC_vect) {
  adcDone = true;
}
ISR(WDT_vect) {
  Sleepy::watchdogEvent();
}


//#define LED_PIN (13)

volatile int f_timer = 0;

#define NODEID      4
//uint8_t NODEID = 0;
#define NETWORKID   100
#define GATEWAYID   31
#define FREQUENCY   RF69_868MHZ //Match this with the version of your Moteino! (others: RF69_433MHZ, RF69_868MHZ)
#define KEY         "sampleEncryptKey" //has to be same 16 characters/bytes on all nodes, not more not less!
#define LED         13
//#define RADIOSW     4
#define SERIAL_BAUD 57600
#define ACK_TIME    450  // # of ms to wait for an ack was 30
bool promiscuousMode = false;

#define EV0 999
#define tMin -20
#define tMax 80
int tT0 = 999;
int maxT = 999;
int minT = 999;

byte resetT = 0; // reset max / min

//int TRANSMITPERIOD = 60000; //transmit a packet to gateway so often (in ms)
int TRANSMITPERIOD = 54980; // was 54750 // 54850 // 54900 // 54950 // 54975 //*54580*//?54985?// 55000 // 55015 // 55025 // 55050 // 55100
//byte sendSize = 0;
//boolean requestACK = false;
//SPIFlash flash(8, 0xEF30); //EF40 for 16mbit windbond chip
RFM69 radio;

//bool waitForRF = 0;

typedef struct {
  // cannot be more than 12 bytes (14 gives error???)
  uint8_t           node;
  uint8_t           tran;
  int16_t           batt;   // battery voltage in millivolts
  int16_t           value1; // Current temperature in dec * 100
  int16_t           value2; // Minimum temperature in dec * 100
  int16_t           value3; // Maximum temperature in dec * 100
  int16_t           value4; // Maximum temperature in dec * 100
} Payload;
Payload theData;

long lastPeriod = -1;


// *** SETUP ***
// *** SETUP ***
// *** SETUP ***
void setup() {
  Serial.begin(SERIAL_BAUD);
  Serial.print("sDesc: ");
  Serial.println(sDesc);
  Serial.print("sVersion: ");
  Serial.println(sVersion);
  Serial.print("hVersion: ");
  Serial.println(hVersion);

  //pinMode(RADIOSW, OUTPUT);
  //digitalWrite(RADIOSW, HIGH);
  //delay(100);
  radio.initialize(FREQUENCY, NODEID, NETWORKID);
  radio.setHighPower(); //uncomment only for RFM69HW!
  radio.encrypt(KEY);
  radio.promiscuous(promiscuousMode);
  char buff[50];
  sprintf(buff, "\nTransmitting at %d Mhz...", FREQUENCY == RF69_433MHZ ? 433 : FREQUENCY == RF69_868MHZ ? 868 : 915);
  Serial.println(buff);

  cli();
  CLKPR = bit(CLKPCE);
  sei();

  pinMode(ONE_WIRE_POW, OUTPUT);
  digitalWrite(ONE_WIRE_POW, HIGH);
  Serial.println("Dallas Temperature IC Control Library Demo");

  sensors.begin();
  numberOfDevices = sensors.getDeviceCount();

  Serial.print("Locating devices...");
  Serial.print("Found ");
  Serial.print(numberOfDevices, DEC);
  Serial.println(" devices.");
  Serial.print("Parasite power is: ");
  if (sensors.isParasitePowerMode()) Serial.println("ON");
  else Serial.println("OFF");

  for (int i = 0; i < numberOfDevices; i++)
  {
    if (sensors.getAddress(tempDeviceAddress, i))
    {
      Serial.print("Found device ");
      Serial.print(i, DEC);
      Serial.print(" with address: ");
      printAddress(tempDeviceAddress);
      Serial.println("");
      Serial.print("Setting resolution to ");
      Serial.println(TEMPERATURE_PRECISION, DEC);
      sensors.setResolution(tempDeviceAddress, TEMPERATURE_PRECISION);
      Serial.print("Resolution actually set to: ");
      Serial.println(sensors.getResolution(tempDeviceAddress), DEC);
      Serial.println("");
    } else {
      Serial.print("Found ghost device at ");
      Serial.print(i, DEC);
      Serial.println(" but could not detect address. Check power and cabling");
      Serial.println("");
    }
  }

  delay(1000);
}



// *** LOOP ***
// *** LOOP ***
// *** LOOP ***
void loop() {
  //readTempVolts();
  readVcc();
  calcT();

  //fill in the struct with new values
  theData.node = NODEID;
#ifdef DEBUG_MIN
  Serial.print("Node = ");
  Serial.print(theData.node);
  Serial.print("; ");
  Serial.print("Tran = ");
  Serial.print(theData.tran);
  Serial.print("; ");
  Serial.print("Batt = ");
  Serial.print(theData.batt);
  Serial.print("; ");
  Serial.print("Value1 = ");
  Serial.print(theData.value1);
  Serial.print("; ");
  Serial.print("Value2 = ");
  Serial.print(theData.value2);
  Serial.print("; ");
  Serial.print("Value3 = ");
  Serial.print(theData.value3);
  Serial.print(";");
  Serial.print("; theData.value4 = ");
  Serial.println(theData.value4);
#endif

  if (radio.sendWithRetry(GATEWAYID, (const void*)(&theData), sizeof(theData)), 1)  // works??
  {
    Serial.println(" RF ok");
  }
  else
  {
    Serial.println(" RF not ok");
    //int dt = random(0,3);
    //delay(dt);
  }

  //radio.receiveDone(); // not sure if this will help - makes no difference
  int rfDelay1 = 400;
  int rfDelay2 = 10;
  int rfCDelay = 60;
  delay(rfDelay1);
  int rfC = 0;

  theData.tran = 0;
  theData.node = 0;

  //Serial.print(" Node = ");
  //Serial.print(theData.node);
  //Serial.print(", Tran = ");
  //Serial.println(theData.tran);

  while (rfC < rfCDelay) {
    if (radio.receiveDone()) // ONLY works if adequate delay else get data from previous transmission??/
    {
    theData = *(Payload*)radio.DATA;
    if ((theData.tran == 3) && (theData.node == NODEID))
    {
      radio.sendACK();
      resetT = 0;
#ifdef DEBUG_ON
      Serial.print(" rfC delay = ");
      Serial.print(rfDelay1 + (rfC * rfDelay2));
      Serial.println("ms -> ACK (tran = 3)");
      Serial.print(" Received data: [NODE = ");
      Serial.print(theData.node);
      Serial.print(", Tran = ");
      Serial.print(theData.tran);
      Serial.println("] ");
#endif
      break;
    }

 
    if ((theData.tran == 99) && (theData.node == NODEID))
    {
      radio.sendACK();
      resetT = 1;
#ifdef DEBUG_ON
      Serial.print(" rfC delay = ");
      Serial.print(rfDelay1 + (rfC * rfDelay2));
      Serial.println("ms -> ACK sent (tran 99)");
      Serial.print(" Received data: [NODE = ");
      Serial.print(theData.node);
      Serial.print(", Tran = ");
      Serial.print(theData.tran);
      Serial.println("] ");
#endif
      break;
    }

    if (rfC < rfCDelay) delay(rfDelay2);
    }
    rfC++;
  }
  
  Serial.flush();
  radio.sleep();
  Sleepy::loseSomeTime(TRANSMITPERIOD);
  //}
}

// *** End LOOP ***
// *** End LOOP ***
// *** End LOOP ***



// FUNCTION Blink (blink a led)
void Blink(byte PIN, int DELAY_MS)
{
  pinMode(PIN, OUTPUT);
  digitalWrite(PIN, HIGH);
  delay(DELAY_MS);
  digitalWrite(PIN, LOW);
}



// FUNCTION printAddress (print a DS18B20 device address)
void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}


// FUNCTION readVcc (read the battery voltage)
long readVcc() {
  long result;
  set_sleep_mode(SLEEP_MODE_ADC);
  // Read 1.1V reference against AVcc
  ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
  delay(2); // Wait for Vref to settle
  ADCSRA |= _BV(ADSC); // Convert
  while (bit_is_set(ADCSRA, ADSC));
  result = ADCL;
  result |= ADCH << 8;
  result = 1126400L / result; // Back-calculate AVcc in mV
  theData.batt = result;
  //sleep_mode();
  return result;
}



// FUNCTION calcT (calculate temperature and set max and min etc)
void calcT() {
  digitalWrite(ONE_WIRE_POW, HIGH);
  delay(5);
  sensors.begin();
  sensors.getAddress(tempDeviceAddress, 0);
  sensors.setResolution(tempDeviceAddress, 12);
  sensors.requestTemperatures();

  tT0 = EV0;
  float tempC = EV0;
  tempC = sensors.getTempC(tempDeviceAddress);
  digitalWrite(ONE_WIRE_POW, LOW);

  if ((tempC < tMin) || (tempC > tMax)) {
    tT0 = EV0;
  } else {
    tT0 = tempC * 100; // avoids dealing with rounding
  }

  if (tT0 != 999) {
    if ((tT0 >= maxT) || (maxT == EV0)) {
      maxT = tT0;
    }
    if ((tT0 <= minT) || (minT == EV0)) {
      minT = tT0;
    }
  }

  theData.value1 = tT0;

  if (resetT == 1) {
    maxT = tT0;
    minT = tT0;
    resetT = 0;
    #ifdef DEBUG_MIN
    Serial.println(" **** Temps reset ......");
    #endif
  }

  theData.tran = 2;
  theData.value3 = maxT;
  theData.value2 = minT;
  #ifdef DEBUG_ON
  Serial.print("\nTemp / Min / Max: ");
  Serial.print(tT0);
  Serial.print(" / ");
  Serial.print(minT);
  Serial.print(" / ");
  Serial.println(maxT);
  #endif
}
