#include <RFM69.h>
#include <SPI.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <JeeLib.h>
#include <avr/sleep.h>
#include <EEPROM.h>

#define sDesc "Falco Manager Node"
#define sVersion "v0.5.4"
#define hVersion "v0.5.0"

//#define DEBUG_ON
#define DEBUG_MIN
//#define KEY_16

#define ONE_WIRE_BUS 8
#define ONE_WIRE_POW 9
#define TEMPERATURE_PRECISION 12

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);
int numberOfDevices;
DeviceAddress tempDeviceAddress;
 
volatile bool adcDone;
ISR(ADC_vect) {
  adcDone = true;
}
ISR(WDT_vect) {
  Sleepy::watchdogEvent();
}

//#define LED_PIN (13)

volatile int f_timer = 0;

#define NODEID        5
#define NODEID_SU     1
#define NETWORKID     100
#define NETWORKID_SU  1
#define GATEWAYID     31
#define FREQUENCY     RF69_868MHZ //Match this with the version of your Moteino! (others: RF69_433MHZ, RF69_868MHZ)
#define KEY           "sampleEncryptKey" //has to be same 16 characters/bytes on all nodes, not more not less!
#define KEY_SU        "setup1EncryptKey" //has to be same 16 characters/bytes on all nodes, not more not less!
#define LED           13
//#define RADIOSW     4
#define SERIAL_BAUD   57600
#define ACK_TIME      450  // # of ms to wait for an ack was 30
bool promiscuousMode = false;

#define EV0 999
#define tMin -20
#define tMax 80
int tT0 = 999;
int maxT = 999;
int minT = 999;

byte resetT = 0; // reset max / min

//int TRANSMITPERIOD = 60000; //transmit a packet to gateway so often (in ms)
int TRANSMITPERIOD = 54980; // was 54750 // 54850 // 54900 // 54950 // 54975 //*54580*//?54985?// 55000 // 55015 // 55025 // 55050 // 55100
//byte sendSize = 0;
//boolean requestACK = false;
//SPIFlash flash(8, 0xEF30); //EF40 for 16mbit windbond chip
RFM69 radio;

//bool waitForRF = 0;

typedef struct {
  // cannot be more than 12 bytes (14 gives error???)
  uint8_t           node;
  uint8_t           tran;
  int16_t           batt;   // battery voltage in millivolts
  int16_t           value1; // Current temperature in dec * 100
  int16_t           value2; // Minimum temperature in dec * 100
  int16_t           value3; // Maximum temperature in dec * 100
  int16_t           value4; // Maximum temperature in dec * 100
  #ifdef KEY_16
  int16_t           value5; // Maximum temperature in dec * 100
  int16_t           value6; // Maximum temperature in dec * 100
  int16_t           value7; // Maximum temperature in dec * 100
  int16_t           value8; // Maximum temperature in dec * 100
  #endif
} Payload;
Payload theData;

long lastPeriod = -1;
bool addNode = 0;
uint8_t nodeIDRF = NODEID;
uint8_t networkIDRF = NETWORKID;
char keyRF[17];
//char setupData[10];

// *** SETUP ***
// *** SETUP ***
// *** SETUP ***
void setup() {
  Serial.begin(SERIAL_BAUD);
  Serial.print("Software description: ");
  Serial.println(sDesc);
  Serial.print("Software version: ");
  Serial.println(sVersion);
  Serial.print("Hardware version: ");
  Serial.println(hVersion);

  #ifdef DEBUG_ON
  Serial.println("DEBUG_ON");
  #endif
  #ifdef DEBUG_MIN
  Serial.println("DEBUG_MIN");
  #endif  
  #ifdef KEY_16
  Serial.println("KEY_16");
  #endif

  //pinMode(RADIOSW, OUTPUT);
  //digitalWrite(RADIOSW, HIGH);
  //delay(100);

  initializeRadio();

  byte temperature =  radio.readTemperature(-1); // -1 = user cal factor, adjust for correct ambient
  byte fTemp = 1.8 * temperature + 32; // 9/5=1.8
  Serial.print( "Radio Temp is ");
  Serial.print(temperature);
  Serial.print("C, ");
  Serial.print(fTemp); //converting to F loses some resolution, obvious when C is on edge between 2 values (ie 26C=78F, 27C=80F)
  Serial.println('F');
      
  cli();
  CLKPR = bit(CLKPCE);
  sei();

  pinMode(3, INPUT);
  pinMode(ONE_WIRE_POW, OUTPUT);
  digitalWrite(ONE_WIRE_POW, HIGH);
 
  /*
  addNode = digitalRead(3);
  Serial.print("\naddNode = ");
  Serial.println(addNode);
  if (addNode == 0) Serial.println("Digtal 3 = LOW\n");
  if (addNode == 1) Serial.println("Digtal 3 = HIGH\n");
    
  char lo = 'A';
  char hi = 'B';
  uint16_t xn = lo | uint16_t(hi) << 8;  // unsigned
  char lo2 = xn & 0xFF;
  char hi2 = xn >> 8;
  Serial.println(char(lo));
  Serial.println(char(hi));
  Serial.println(String(xn));
  Serial.println(char(lo2));
  Serial.println(char(hi2));
  */
  
  sensors.begin();
  numberOfDevices = sensors.getDeviceCount();

  Serial.print("Locating DS18B20 devices... ");
  Serial.print("Found ");
  Serial.print(numberOfDevices, DEC);
  Serial.println(" device/s.");
  Serial.print("Parasite power is: ");
  if (sensors.isParasitePowerMode()) Serial.println("ON");
  else Serial.println("OFF");

  for (int i = 0; i < numberOfDevices; i++)
  {
    if (sensors.getAddress(tempDeviceAddress, i))
    {
      Serial.print("Found device ");
      Serial.print(i, DEC);
      Serial.print(" with address: ");
      printAddress(tempDeviceAddress);
      Serial.println("");
      Serial.print("Setting resolution to ");
      Serial.println(TEMPERATURE_PRECISION, DEC);
      sensors.setResolution(tempDeviceAddress, TEMPERATURE_PRECISION);
      Serial.print("Resolution actually set to: ");
      Serial.println(sensors.getResolution(tempDeviceAddress), DEC);
      Serial.println("");
    } else {
      Serial.print("Found ghost device at ");
      Serial.print(i, DEC);
      Serial.println(" but could not detect address. Check power and cabling");
      Serial.println("");
    }
  }

  delay(1000);
}



// *** LOOP ***
// *** LOOP ***
// *** LOOP ***
void loop() {
  //readTempVolts();
  readVcc();
  calcT();

  //fill in the struct with new values
  theData.node = NODEID;
  #ifdef DEBUG_MIN
  unsigned long msc = millis();
  uint16_t msSec = msc / 60000;
  uint16_t ms = msc % 60000; 
  Serial.print("Millis = ");
  Serial.print(msSec);
  Serial.print(" ");
  Serial.print(ms);
  Serial.print(": Node = ");
  Serial.print(theData.node);
  Serial.print("; Tran = ");
  Serial.print(theData.tran);
  Serial.print("; Batt = ");
  Serial.print(theData.batt);
  Serial.print("; Value1 = ");
  Serial.print(theData.value1);
  Serial.print("; Value2 = ");
  Serial.print(theData.value2);
  Serial.print("; Value3 = ");
  Serial.print(theData.value3);
  Serial.print("; Value4 = ");
  Serial.print(theData.value4);
  Serial.println("");
  #endif

  if (radio.sendWithRetry(GATEWAYID, (const void*)(&theData), sizeof(theData)), 1)  // works??
  {
    #ifdef DEBUG_ON
    Serial.println(" RF ok");
    #endif
  }
  else
  {
    #ifdef DEBUG_MIN
    Serial.println(" RF not ok");
    #endif
  }

  //radio.receiveDone(); // not sure if this will help - makes no difference
  int rfDelay1 = 400;
  int rfDelay2 = 10;
  int rfCDelay = 60;
  delay(rfDelay1);
  int rfC = 0;

  theData.tran = 0;
  theData.node = 0;
  
  byte packetCount = 0;
  
  while (rfC < rfCDelay) {
    if (radio.receiveDone()) // ONLY works if adequate delay else get data from previous transmission??/
    {
    theData = *(Payload*)radio.DATA;

    Serial.print("#[");
    Serial.print(++packetCount);
    Serial.print(']');
    Serial.print('[');
    Serial.print(radio.SENDERID, DEC);
    Serial.print("] ");
    //if (!promiscuousMode)
    //{
      Serial.print("to [");
      Serial.print(radio.TARGETID, DEC);
      Serial.print("] ");
    //}
    for (byte i = 0; i < radio.DATALEN; i++)
    {
    Serial.print("[");
    Serial.print(i);
    Serial.print(":");
      Serial.print((char)radio.DATA[i]);
    Serial.print("|");
    char x = (char)radio.DATA[i];
    Serial.print(x, DEC);
    Serial.print("] ");
    }
    Serial.print(" [RX_RSSI:");
    Serial.print(radio.RSSI);
    Serial.print("]");
    
    Serial.print("[DATALEN:");
    Serial.print(radio.DATALEN);
    Serial.println("]");

    if ((theData.tran == 3) && (theData.node == NODEID))
    {
      radio.sendACK();
      resetT = 0;
      #ifdef DEBUG_MIN
      Serial.print(" rfC delay = ");
      Serial.print(rfDelay1 + (rfC * rfDelay2));
      Serial.println("ms -> ACK (tran = 3)");
      Serial.print(" Received data: [NODE = ");
      Serial.print(theData.node);
      Serial.print(", Tran = ");
      Serial.print(theData.tran);
      Serial.print(", Network = ");
      Serial.print(theData.batt);
      Serial.print(", V1 = ");
      Serial.print(theData.value1);
      Serial.print(", V2 = ");
      Serial.print(theData.value2);
      Serial.print(", V3 = ");
      Serial.print(theData.value3);
      Serial.print(", V4 = ");
      Serial.print(theData.value4);
      #ifdef KEY_16
      Serial.print(", V5 = ");
      Serial.print(theData.value5);
      Serial.print(", V6 = ");
      Serial.print(theData.value6);
      Serial.print(", V7 = ");
      Serial.print(theData.value7);
      Serial.print(", V8 = ");
      Serial.print(theData.value8);
      String pw = "";      
      pw = String(theData.value1 & 0xFF);
      pw = pw + String(theData.value1 >> 8);
      pw = pw + String(theData.value2 & 0xFF);
      pw = pw + String(theData.value2 >> 8);
      pw = pw + String(theData.value3 & 0xFF);
      pw = pw + String(theData.value3 >> 8);
      pw = pw + String(theData.value4 & 0xFF);
      pw = pw + String(theData.value4 >> 8);
      pw = pw + String(theData.value5 & 0xFF);
      pw = pw + String(theData.value5 >> 8);
      pw = pw + String(theData.value6 & 0xFF);
      pw = pw + String(theData.value6 >> 8);
      pw = pw + String(theData.value7 & 0xFF);
      pw = pw + String(theData.value7 >> 8);
      pw = pw + String(theData.value8 & 0xFF);
      pw = pw + String(theData.value8 >> 8);
      Serial.print("-");
      Serial.print(pw);
      #endif
      Serial.println("] ");
      #endif
      break;
    }
 
    if ((theData.tran == 99) && (theData.node == NODEID))
    {
      radio.sendACK();
      resetT = 1;
      #ifdef DEBUG_ON
      Serial.print(" rfC delay = ");
      Serial.print(rfDelay1 + (rfC * rfDelay2));
      Serial.println("ms -> ACK sent (tran 99)");
      Serial.print(" Received data: [NODE = ");
      Serial.print(theData.node);
      Serial.print(", Tran = ");
      Serial.print(theData.tran);    
      Serial.println("] ");
      #endif
      break;
    }

    if (rfC < rfCDelay) delay(rfDelay2);
    }
    rfC++;
  }
  
  Serial.flush();
  radio.sleep();
  Sleepy::loseSomeTime(TRANSMITPERIOD);
  //}
}

// *** End LOOP ***
// *** End LOOP ***
// *** End LOOP ***



// FUNCTION Blink (blink a led)
void Blink(byte PIN, int DELAY_MS)
{
  pinMode(PIN, OUTPUT);
  digitalWrite(PIN, HIGH);
  delay(DELAY_MS);
  digitalWrite(PIN, LOW);
}



// FUNCTION printAddress (print a DS18B20 device address)
void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}


// FUNCTION readVcc (read the battery voltage)
long readVcc() {
  long result;
  set_sleep_mode(SLEEP_MODE_ADC);
  // Read 1.1V reference against AVcc
  ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
  delay(2); // Wait for Vref to settle
  ADCSRA |= _BV(ADSC); // Convert
  while (bit_is_set(ADCSRA, ADSC));
  result = ADCL;
  result |= ADCH << 8;
  result = 1126400L / result; // Back-calculate AVcc in mV
  theData.batt = result;
  //sleep_mode();
  return result;
}



// FUNCTION calcT (calculate temperature and set max and min etc)
void calcT() {
  digitalWrite(ONE_WIRE_POW, HIGH);
  delay(5);
  sensors.begin();
  sensors.getAddress(tempDeviceAddress, 0);
  sensors.setResolution(tempDeviceAddress, 12);
  sensors.requestTemperatures();

  tT0 = EV0;
  float tempC = EV0;
  tempC = sensors.getTempC(tempDeviceAddress);
  digitalWrite(ONE_WIRE_POW, LOW);

  if ((tempC < tMin) || (tempC > tMax)) {
    tT0 = EV0;
  } else {
    tT0 = tempC * 100; // avoids dealing with rounding
  }

  if (tT0 != 999) {
    if ((tT0 >= maxT) || (maxT == EV0)) {
      maxT = tT0;
    }
    if ((tT0 <= minT) || (minT == EV0)) {
      minT = tT0;
    }
  }

  theData.value1 = tT0;

  if (resetT == 1) {
    maxT = tT0;
    minT = tT0;
    resetT = 0;
    #ifdef DEBUG_MIN
    Serial.println(" -> Max / Min reset");
    #endif
  }

  theData.tran = 2;
  theData.value3 = maxT;
  theData.value2 = minT;
  #ifdef DEBUG_ON
  Serial.print("\nTemp / Min / Max: ");
  Serial.print(tT0);
  Serial.print(" / ");
  Serial.print(minT);
  Serial.print(" / ");
  Serial.println(maxT);
  #endif
}


void initializeRadio()
{
  if (addNode == 0)
  {
    nodeIDRF = NODEID;
    networkIDRF = NETWORKID;
    keyRF[0] = 's';
    keyRF[1] = 'a';
    keyRF[2] = 'm';
    keyRF[3] = 'p';
    keyRF[4] = 'l';
    keyRF[5] = 'e';
    keyRF[6] = 'E';
    keyRF[7] = 'n';
    keyRF[8] = 'c';
    keyRF[9] = 'r';
    keyRF[10] = 'y';
    keyRF[11] = 'p';
    keyRF[12] = 't';
    keyRF[13] = 'K';
    keyRF[14] = 'e';
    keyRF[15] = 'y';
    keyRF[16] = '\0';  
  }
  
  if (addNode == 1)
  {
    nodeIDRF = NODEID_SU;
    networkIDRF = NETWORKID_SU;
    keyRF[0] = 's';
    keyRF[1] = 'e';
    keyRF[2] = 't';
    keyRF[3] = 'u';
    keyRF[4] = 'p';
    keyRF[5] = '1';
    keyRF[6] = 'E';
    keyRF[7] = 'n';
    keyRF[8] = 'c';
    keyRF[9] = 'r';
    keyRF[10] = 'y';
    keyRF[11] = 'p';
    keyRF[12] = 't';
    keyRF[13] = 'K';
    keyRF[14] = 'e';
    keyRF[15] = 'y';
    keyRF[16] = '\0';  
  } 
  
  if (addNode == 2)
  {
    nodeIDRF = EEPROM.read(2);
    networkIDRF = EEPROM.read(3);
    for (int i = 4; i < 20; i++)
    {
      int x = i - 4;
      keyRF[i] = EEPROM.read(i);
    }  
    keyRF[16] = '\0';
  }
  
  Serial.print( "\nnodeIDRF / networkIDRF / keyRF: ");
  Serial.print(nodeIDRF);
  Serial.print(" | ");
  Serial.println(networkIDRF);  
  Serial.print("[");  
  Serial.print(keyRF);  
  Serial.println("]");
  Serial.print(" addNode = ");  
  Serial.println(addNode);
  
  radio.initialize(FREQUENCY, nodeIDRF, networkIDRF);
  radio.setHighPower(); //uncomment only for RFM69HW!
  radio.encrypt(keyRF);
  radio.promiscuous(promiscuousMode);
  char buff[50];
  sprintf(buff, "\nTransmitting at %d Mhz...", FREQUENCY == RF69_433MHZ ? 433 : FREQUENCY == RF69_868MHZ ? 868 : 915);
  Serial.println(buff);
}
